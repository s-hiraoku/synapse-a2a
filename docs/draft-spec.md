# 🤖 Agent-to-Agent (A2A) Interoperability Framework

## ~ 汎用 A2A ラッパーによるエージェント間協調システム設計案 ~

### 1. 概要

本プロジェクトは、異なる LLM エージェント（Gemini CLI, Claude Code 等）が同一または複数のセッションで動作する際、互いの作業内容を理解し、必要に応じてリアルタイムで介入・修正を行える環境の構築を目的とする。通信プロトコルとして Google が提唱する **A2A (Agent-to-Agent Protocol)** を採用し、各エージェントを「汎用ラッパー」で包むことで、対等かつ双方向の通信を実現する。

---

### 2. システムアーキテクチャ

各エージェントは独立した CLI プロセスとして実行されるが、汎用的な Python ラッパー（Wrapper）がその「親」として振る舞う。

#### 主要コンポーネント

- **A2A Server (FastAPI):** 外部（他エージェントのラッパー）からの A2A メッセージを受信し、状態を外部に露出するインターフェース。
- **Terminal Controller:** CLI のプロセス管理、標準入出力の監視、出力を解析して状態（IDLE/BUSY/ERROR）を判定するロジックを担う。
- **Pseudo-Terminal (PTY):** OS レベルで「仮想端末」を生成。ターゲット CLI に「人間が操作している」と誤認させ、リッチな対話機能を維持したまま制御する。
- **Agent Profile (YAML):** CLI ごとの起動コマンドや、入力待ち状態を検知するための正規表現パターンを定義した設定ファイル。

---

### 3. AgentID とレジストリ

エージェントを一意に特定し、相互に発見するための仕組み。

- **ID 生成ルール:** `SHA256(hostname + working_dir + agent_type)` のハッシュ値。
- _理由:_ 同一プロジェクト・同一エージェントなら再起動後も同じ ID になり、セッションの継続性が保たれる。

- **発見の仕組み (Local Registry):**
- ラッパーは起動時に `~/.a2a/registry/[AgentID].json` を作成。
- ファイル内には自身の Endpoint（例: `http://localhost:8100`）とステータスを記述。
- 他エージェントはこのディレクトリをスキャンして、接続先を特定する。

---

### 4. 意思疎通と介入のロジック

#### 4.1 コンテキストの共有

- **圧縮共有方式:** 情報の提供主（エージェント自身）が、現在の作業状況を LLM 自身で要約・圧縮し、A2A 経由でプッシュする。
- **利点:** 不要なログ送信を抑え、相手にとって重要な情報のみを効率的に伝達できる。

#### 4.2 優先度ベースの介入 (Intervention)

A2A メッセージには **Priority (1-5)** を設定し、ラッパーが介入タイミングを制御する。

| 優先度            | 定義                   | ラッパーのアクション                                                                        |
| ----------------- | ---------------------- | ------------------------------------------------------------------------------------------- |
| **5 (Emergency)** | 重大な方針ミス・誤操作 | **即時介入:** 実行中のプロセスに `SIGINT` (Ctrl+C) を送り、強制停止させてから新指示を注入。 |
| **3 (Warning)**   | 改善提案・補足         | **待機介入:** 現在のタスク完了（プロンプト待ち）まで待ち、次の入力時に指示を先頭に挿入。    |
| **1 (Info)**      | 進捗報告               | **非介入:** 内部メモリのコンテキスト更新のみ。相手が自発的に確認した際に伝える。            |

---

### 5. 実行シーケンス (例: Gemini が Claude に介入)

1. **検知:** Gemini が Claude のコンテキスト（進捗）を確認し、API の選定ミスを発見。
2. **発信:** Gemini が自らの A2A ツールを使い、`TargetID: Claude-001, Priority: 5` で警告を送信。
3. **受信:** Claude 側のラッパーがリクエストを受信。優先度 5 を確認。
4. **介入:** ラッパーが `pty` 経由で `Ctrl+C` を送信し、Claude の処理を中断。
5. **修正:** ラッパーが「Gemini からの緊急指摘：〇〇を修正せよ」というテキストを標準入力に流し込む。
6. **変更:** Claude が指示を認識し、作業方針を切り替える。

#### 5.2 ユーザー体験 (UX) のゴール

ユーザーは、片方のエージェント（例: Gemini）のターミナルから、もう片方のエージェント（例: Claude）を自然言語で直接制御できる。

**Example Usage:**

```bash
# Gemini のターミナルにて
user> @ClaudeCode 今実施している処理を止めて、先に `tests/` の修正を優先してください。
```

**裏側のフロー:**

1. **認識:** Gemini が `@ClaudeCode` を検知し、A2A ツールを呼び出す判断をする。
2. **検索:** Registry (`~/.a2a/registry/`) から Claude の AgentID と Endpoint を取得。
3. **実行:** Gemini が `POST /message` (Priority: 5) を送信。
4. **介入:** Claude 側ラッパーが `SIGINT` を発行して処理を中断し、Gemini からの指示を入力。
5. **応答:** Claude が「了解しました。テストの修正に移ります」と応答し、作業を切り替える。

**Note: 完全に対称な双方向制御**
このアーキテクチャは対称です。Gemini も Claude と同様に `Synapse A2A` ラッパー内で起動されるため、Claude のコンソールから **`@Gemini 処理を止めて`** と入力すれば、同様に Gemini の処理を中断・介入することが可能です。

#### 5.3 ユースケース: 監視と自動リトライ (Watchdog)

「Gemini に Claude を監視させ、止まっていたら突っつく」といったシナリオも、`GET /status` を活用することで実現可能です。

**Flow:**

1. **指示:** User > `@Gemini Claude が止まっていないか定期的に見て、サボっていたら「続きをやって」と言って。`
2. **監視:** Gemini (またはループ実行スクリプト) が定期的に Claude の `GET /status` を叩く。
3. **検知:** `{"status": "IDLE", "context": "...(まだ途中)..."}` を確認。
4. **介入:** Gemini が `POST /message` で `＠ClaudeCode 続きをお願い` を送信。
5. **再開:** Claude がハッとして作業を再開する。

---

### 6. 今後の実装ロードマップ

1. **Phase 1: 最小構成プロトタイプ**

- Python + FastAPI + `pty` で Claude Code を起動し、HTTP 経由で文字を送り込めることを確認。

2. **Phase 2: Agent Profile & ID 管理の実装**

- YAML 設定の読み込み機能と、ローカルレジストリによる自動発見の実装。

3. **Phase 3: プロンプト調整**

- `CLAUDE.md` や `GEMINI.md` に、A2A ツールを使ってコンテキストを自発的に圧縮・共有する指示を追加。
