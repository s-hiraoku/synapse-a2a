"""Spawn a single agent in a new terminal pane.

Provides the core ``spawn_agent()`` function used by both
the ``synapse spawn`` CLI command and the ``POST /spawn`` API endpoint.
"""

from __future__ import annotations

import os
import shlex
import subprocess
from dataclasses import dataclass

from synapse.port_manager import PortManager, is_port_available
from synapse.registry import AgentRegistry
from synapse.server import load_profile
from synapse.terminal_jump import create_panes, detect_terminal_app


@dataclass
class SpawnResult:
    """Result of a spawn_agent() call."""

    agent_id: str
    port: int
    terminal_used: str
    status: str  # "submitted" | "failed"


def spawn_agent(
    profile: str,
    port: int | None = None,
    name: str | None = None,
    role: str | None = None,
    skill_set: str | None = None,
    terminal: str | None = None,
    tool_args: list[str] | None = None,
) -> SpawnResult:
    """Spawn a single agent in a new terminal pane.

    Args:
        profile: Agent profile name (claude, gemini, codex, etc.).
        port: Explicit port number. Auto-assigned if None.
        name: Custom agent name.
        role: Agent role description.
        skill_set: Skill set to activate.
        terminal: Terminal app to use. Auto-detected if None.
        tool_args: Extra arguments passed through to the underlying CLI tool
            (e.g., ``["--dangerously-skip-permissions"]``).

    Returns:
        SpawnResult with agent_id, port, terminal_used, status.

    Raises:
        FileNotFoundError: If profile is invalid.
        RuntimeError: If port unavailable, ports exhausted, or no terminal.
    """
    # 1. Validate profile
    load_profile(profile)

    # 2. Resolve port
    if port is not None:
        if not is_port_available(port):
            raise RuntimeError(f"Port {port} is already in use")
    else:
        registry = AgentRegistry()
        pm = PortManager(registry)
        port = pm.get_available_port(profile)
        if port is None:
            raise RuntimeError(pm.format_exhaustion_error(profile))

    # 3. Detect terminal
    terminal_used = terminal or detect_terminal_app()
    if terminal_used is None:
        raise RuntimeError(
            "No supported terminal detected. "
            "Supported: tmux, iTerm2, Terminal.app, Ghostty, zellij"
        )

    # 4. Build agent spec: profile:name:role:skill_set:port:headless
    agent_spec = ":".join(
        [
            profile,
            name or "",
            role or "",
            skill_set or "",
            str(port),
            "headless",
        ]
    )

    # 5. Create pane commands via existing infrastructure
    commands = create_panes(
        [agent_spec],
        terminal_app=terminal_used,
        all_new=True,
        tool_args=tool_args,
        cwd=os.getcwd(),
    )

    if not commands:
        raise RuntimeError(
            f"No commands generated by create_panes for terminal '{terminal_used}'"
        )

    # 6. Execute commands
    try:
        for cmd in commands:
            subprocess.run(shlex.split(cmd), check=True)
    except subprocess.CalledProcessError as e:
        raise RuntimeError(f"Failed to spawn agent: {e}") from e

    agent_id = f"synapse-{profile}-{port}"

    return SpawnResult(
        agent_id=agent_id,
        port=port,
        terminal_used=terminal_used,
        status="submitted",
    )


def wait_for_agent(
    agent_id: str,
    timeout: float = 30.0,
    poll_interval: float = 0.5,
) -> dict | None:
    """Wait for a spawned agent to register and become alive.

    Uses fixed-interval polling against the file-based registry.
    Fixed interval is preferred over exponential backoff here because
    registry reads are cheap (single file read) and agent boot times
    are unpredictable â€” we want consistent responsiveness.

    Args:
        agent_id: The agent ID to wait for (e.g. "synapse-claude-8100").
        timeout: Maximum seconds to wait (default 30s).
        poll_interval: Seconds between polls (default 0.5s).

    Returns:
        Agent info dict if found and alive, or None if timed out.
    """
    import time

    from synapse.port_manager import is_process_alive

    registry = AgentRegistry()
    deadline = time.monotonic() + timeout

    while time.monotonic() < deadline:
        agents = registry.list_agents()
        if agent_id in agents:
            info = agents[agent_id]
            pid = info.get("pid")
            if pid and is_process_alive(pid):
                return info
        time.sleep(poll_interval)

    return None
